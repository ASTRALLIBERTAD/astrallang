fn get_string_length(s: string) -> int {
    return s.len();
}

fn get_char_at(s: string, pos: int) -> int {
    return s.char_at(pos);
}

fn is_whitespace(ch: int) -> bool {
    if ch == 32 { return true; }
    if ch == 10 { return true; }
    if ch == 13 { return true; }
    if ch == 9 { return true; }
    return false;
}

fn is_digit(ch: int) -> bool {
    return ch >= 48 && ch <= 57;
}

fn is_alpha(ch: int) -> bool {
    if ch >= 65 && ch <= 90 { return true; }
    if ch >= 97 && ch <= 122 { return true; }
    if ch == 95 { return true; }
    return false;
}

fn tokenize(source: string) -> int {
    let len: int = get_string_length(source);
    let mut pos: int = 0;
    
    puts("Starting tokenization...");
    
    while pos < 1000 {
        let ch: int = get_char_at(source, pos);
        
        if ch == 0 {
            break;
        }
        
        if is_whitespace(ch) {
            pos = pos + 1;
        } else if is_digit(ch) {
            puts("TOKEN: NUMBER");
            pos = pos + 1;
        } else if is_alpha(ch) {
            puts("TOKEN: IDENTIFIER");
            pos = pos + 1;
        } else if ch == 43 {
            puts("TOKEN: PLUS");
            pos = pos + 1;
        } else if ch == 45 {
            let next: int = get_char_at(source, pos + 1);
            if next == 62 {
                puts("TOKEN: ARROW");
                pos = pos + 2;
            } else {
                puts("TOKEN: MINUS");
                pos = pos + 1;
            }
        } else if ch == 42 {
            puts("TOKEN: STAR");
            pos = pos + 1;
        } else if ch == 47 {
            let next: int = get_char_at(source, pos + 1);
            if next == 47 {
                while pos < 1000 {
                    let c: int = get_char_at(source, pos);
                    if c == 10 {
                        break;
                    }
                    if c == 0 {
                        break;
                    }
                    pos = pos + 1;
                }
            } else {
                puts("TOKEN: SLASH");
                pos = pos + 1;
            }
        } else if ch == 37 {
            puts("TOKEN: PERCENT");
            pos = pos + 1;
        } else if ch == 61 {
            let next: int = get_char_at(source, pos + 1);
            if next == 61 {
                puts("TOKEN: EQUAL");
                pos = pos + 2;
            } else {
                puts("TOKEN: ASSIGN");
                pos = pos + 1;
            }
        } else if ch == 33 {
            let next: int = get_char_at(source, pos + 1);
            if next == 61 {
                puts("TOKEN: NOT_EQUAL");
                pos = pos + 2;
            } else {
                puts("TOKEN: NOT");
                pos = pos + 1;
            }
        } else if ch == 60 {
            let next: int = get_char_at(source, pos + 1);
            if next == 61 {
                puts("TOKEN: LESS_EQUAL");
                pos = pos + 2;
            } else {
                puts("TOKEN: LESS");
                pos = pos + 1;
            }
        } else if ch == 62 {
            let next: int = get_char_at(source, pos + 1);
            if next == 61 {
                puts("TOKEN: GREATER_EQUAL");
                pos = pos + 2;
            } else {
                puts("TOKEN: GREATER");
                pos = pos + 1;
            }
        } else if ch == 38 {
            let next: int = get_char_at(source, pos + 1);
            if next == 38 {
                puts("TOKEN: AND");
                pos = pos + 2;
            } else {
                puts("TOKEN: AMPERSAND");
                pos = pos + 1;
            }
        } else if ch == 124 {
            let next: int = get_char_at(source, pos + 1);
            if next == 124 {
                puts("TOKEN: OR");
                pos = pos + 2;
            } else {
                puts("TOKEN: PIPE");
                pos = pos + 1;
            }
        } else if ch == 40 {
            puts("TOKEN: LPAREN");
            pos = pos + 1;
        } else if ch == 41 {
            puts("TOKEN: RPAREN");
            pos = pos + 1;
        } else if ch == 123 {
            puts("TOKEN: LBRACE");
            pos = pos + 1;
        } else if ch == 125 {
            puts("TOKEN: RBRACE");
            pos = pos + 1;
        } else if ch == 91 {
            puts("TOKEN: LBRACKET");
            pos = pos + 1;
        } else if ch == 93 {
            puts("TOKEN: RBRACKET");
            pos = pos + 1;
        } else if ch == 58 {
            puts("TOKEN: COLON");
            pos = pos + 1;
        } else if ch == 59 {
            puts("TOKEN: SEMICOLON");
            pos = pos + 1;
        } else if ch == 44 {
            puts("TOKEN: COMMA");
            pos = pos + 1;
        } else if ch == 34 {
            puts("TOKEN: STRING");
            pos = pos + 1;
            while pos < 1000 {
                let c: int = get_char_at(source, pos);
                if c == 34 {
                    pos = pos + 1;
                    break;
                }
                if c == 0 {
                    break;
                }
                pos = pos + 1;
            }
        } else {
            puts("TOKEN: UNKNOWN");
            pos = pos + 1;
        }
    }
    
    puts("Tokenization complete!");
    return 0;
}

fn main() -> int {
    puts("=== BRN LEXER v1.0 ===");
    
    let source: string = "fn add(x: int) -> int { return x + 1;}";
    tokenize(source);
    
    return 0;
}